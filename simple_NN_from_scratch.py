# -*- coding: utf-8 -*-
"""ass_2_Simple_NN_From_Scratch.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19Hpy918XtN4urhlKzkeq75qI_RD0X5Sz
"""

import random
import math

Neurons= 10

def zeros_matrix(rows, cols):
  """
  Creates a matrix filled with zeros.
      :param rows: the number of rows the matrix should have
      :param cols: the number of columns the matrix should have

      :return: list of lists that form the matrix
  """
  M = []
  while len(M) < rows:
      M.append([])
      while len(M[-1]) < cols:
          M[-1].append(0.0)

  return M

# ___________________________________________________________________________________________________

def matrix_multiply(A, B):
    """
    Returns the product of the matrix A * B
        :param A: The first matrix - ORDER MATTERS!
        :param B: The second matrix
 
        :return: The product of the two matrices
    """
    # Section 1: Ensure A & B dimensions are correct for multiplication
    rowsA = len(A)
    colsA = len(A[0])
    rowsB = len(B)
    colsB = len(B[0])
    if colsA != rowsB:
        raise ArithmeticError(
            'Number of A columns must equal number of B rows.')
 
    # Section 2: Store matrix multiplication in a new matrix
    C = zeros_matrix(rowsA, colsB)
    for i in range(rowsA):
        for j in range(colsB):
            total = 0
            for ii in range(colsA):
                total +=A[i][ii] * B[ii][j]
            C[i][j] = total
 
    return C

# ___________________________________________________________________________________________________
def Sum (x,y):
  New=[[0 for i in range(len(x[0]))] for j in range(len(x))]
  for i in range(len(x)):
      New[i][0]=x[i][0]+y[i][0]
  return New

# ___________________________________________________________________________________________________
def Sub (x,y):

  New=[[0 for i in range(len(x[0]))] for j in range(len(x))]
  for i in range(len(x)):
      New[i][0]=x[i][0]-y[i][0]
  return New

# ___________________________________________________________________________________________________

def Multi (x,y):
  New=[[0 for i in range(len(x[0]))] for j in range(len(x))]
  for i in range(len(x)):
      New[i][0]=x[i][0]*y[i][0]
  return New
# ___________________________________________________________________________________________________
def Multi_value (x,y):
  New=[[0 for i in range(len(y[0]))] for j in range(len(y))]
  for i in range(len(y)):
      New[i][0]=x*y[i][0]
  return New

# ___________________________________________________________________________________________________


def transpose(M):
    """
    Returns a transpose of a matrix.
        :param M: The matrix to be transposed
 
        :return: The transpose of the given matrix
    """
    # Section 1: if a 1D array, convert to a 2D array = matrix
    if not isinstance(M[0],list):
        M = [M]
 
    # Section 2: Get dimensions
    rows = len(M)
    cols = len(M[0])
 
    # Section 3: MT is zeros matrix with transposed dimensions
    MT = zeros_matrix(cols, rows)
 
    # Section 4: Copy values from M to it's transpose MT
    for i in range(rows):
        for j in range(cols):
            MT[j][i] = M[i][j]
 
    return MT


# ___________________________________________________________________________________________________
def exppp_sigmoid(x):
  layer_11=[[0 for i in range(len(x[0]))] for j in range(len(x))]
  for i in range(len(x)):
    for j in range(len(x[0])):
      layer_11[i][j]=1.0/(1.0+math.exp(-1.0*x[i][j]))
       
  return layer_11
# ___________________________________________________________________________________________________

def sigmoid_derivative(x):
  out_1_copy=[[0 for i in range(len(x[0]))] for j in range(len(x))]
  for i in range(len(x)):
    out_1_copy[i][0]=x[i][0]*(1.0-x[i][0])
  return out_1_copy

# ___________________________________________________________________________________________________


class Simple_NN :
  def __init__(self, X_train, y_train):

    self.X_train= X_train
    print('inputs \n' , self.X_train)
    print()

    random.seed(43)
    self.weight_1=[[random.random() for i in range(Neurons)] for j in range(3)]
    print(self.weight_1)
    print()

    
    random.seed(100)
    self.weight_2=[[random.random() for i in range(1)] for j in range(Neurons)]   
    print('weights2 \n',self.weight_2)
    print()

    self.y_train= y_train
    print('y \n',self.y_train)
    print()

    out_1=[[0 for i in range(len(y_train[0]))] for j in range(len(y_train))]

#----------------------------------------
# error=sum(0.5(tj - Oj)**2)            -
#out_1=Oj                               -
#divError=(tj - Oj)                     -
# layer1=Oi                             -
# D_Wij=E(tj - Oj)*Oj(1-Oj)*Oi          -
# Div_sigma(Oj)=Oj(1-Oj)                -
#sigma(j)= (tj - Oj)*Div_sigma(Oj)      -
#----------------------------------------

  def Feedforward(self):
    dot_p=matrix_multiply(X_train , self.weight_1)
    # print(len(dot_p))

    self.Layer_1= exppp_sigmoid(dot_p)
    # print(len(Layer_1))

    dot_p_2=matrix_multiply(self.Layer_1 , self.weight_2)
    # print(len(dot_p_2))

    self.out_1= exppp_sigmoid(dot_p_2)
    # print(len(out_1))
#-------------------------------------------------------------------------------
# dot((self.y - self.output) * sigmoid_derivative(self.output),self.weights2.T)-
# sigma(K) = (tk - Ok)*Ok(1-Ok)   14x1                                         -
# out_1=Ok                                                                     -
# weight_2 :     5x1                                                           -
# weight_2.T :  1x5                                                            -
# 14x5                                                                         -
#                                                                              -
# layer1=Oj                                                                    -
#Div_sigma(Oj)=Oj(1-Oj)   14x5                                                 -
#                                                                              -
# x_train = Oi     14x3                                                        -
# x_train.T     3x14                                                           -
#                                                                              -
# D_Wij_1   : dot (3x14 , 14x5)       3x5                                      -
# D_Wij_1 = E * D_Wij_1                                                        -
#-------------------------------------------------------------------------------

  def Backpropagation(self):
    E=0.005
    divError=Sub (self.y_train,self.out_1)
    Div_Sig = sigmoid_derivative(self.out_1)
    self.sigma = Multi (divError,Div_Sig)
    Layer_1_T=transpose(self.Layer_1)
    # D_Wij=E*dot((tj - Oj)*Oj(1-Oj),Oi)
    sigma_dot_out=matrix_multiply(Layer_1_T,self.sigma)
    D_Wij_2=Multi_value(E , sigma_dot_out)
    # print(len(D_Wij_2))

    divError_2=Sub (self.y_train,self.out_1)
    Div_Sig_2 = sigmoid_derivative(self.out_1)
    self.sigma_2 = Multi (divError_2,Div_Sig_2)

    weight_2_T=transpose(self.weight_2)
    sigma_dot_w2=matrix_multiply(self.sigma_2,weight_2_T)
    Div_sigma =sigmoid_derivative(self.Layer_1)
    Sigma_hidden=Multi(Div_sigma,sigma_dot_w2)
    # print(Sigma_hidden)

    X_train_T=transpose(self.X_train)
    sigmahidden_dot_xtrain=matrix_multiply(X_train_T,Sigma_hidden)
    D_Wij_1=Multi_value(E,sigmahidden_dot_xtrain)
    # print(len(D_Wij_1))

    self.weight_1=Sum(self.weight_1,D_Wij_1)
    self.weight_2=Sum(self.weight_2,D_Wij_2)

X_train = [[1,1,1],[1,2,1],[1,4,1],[2,5,1],[4,4,1],[2,2,1],[2,3,1],[3,3,1],[3,4,1],[6,1,1],[5,5,1],[5,3,1],[3,5,1],[2,4,1],[3,2,1],[4,3,1],[7,3,1],[3,1,1],[5,2,1]]
y_train = [[0],[0],[0],[1],[1],[0],[0],[1],[1],[0],[0],[0],[1],[1],[1],[1],[0],[1],[0]]

NN = Simple_NN(X_train,y_train)

for i in range(100):
    NN.Feedforward()
    NN.Backpropagation()
#    print('--------------------------------')
#

Y_Predict=[[0 for i in range(len(NN.out_1[0]))] for j in range(len(NN.out_1))]
for i in range(len(NN.out_1)):
  Y_Predict[i][0]=round(NN.out_1[i][0] , 3)

print("Y_Predict")
print(Y_Predict)

for i in range(len(Y_Predict)):
  if (Y_Predict[i][0]>=0.5):
    Y_Predict[i][0]=1
  else:
    Y_Predict[i][0]=0

print()

print('Y_Predict',Y_Predict)

def Calculate_accuracy(predicted_y , y):
    counter=0
    index=0
    
    for item in predicted_y:
        if predicted_y [index] == y [index]:
            counter=counter+1
        index=index+1  
    length=len(y)
    # print (counter)
    # print (length)
    return ((counter/length)*100)

# Calculate_accuracy for test 
Calculate_accuracy(Y_Predict , y_train)